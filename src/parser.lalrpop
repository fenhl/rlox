use {
    std::str::FromStr as _,
    lalrpop_util::ParseError,
    crate::ast::*,
};

grammar;

match {
    r"[\t\n\r ]*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    "and" => AND,
    "class" => CLASS,
    "else" => ELSE,
    "false" => FALSE,
    "for" => FOR,
    "fun" => FUN,
    "if" => IF,
    "nil" => NIL,
    "or" => OR,
    "print" => PRINT,
    "return" => RETURN,
    "super" => SUPER,
    "this" => THIS,
    "true" => TRUE,
    "var" => VAR,
    "while" => WHILE,
    r"[A-Z_a-z][0-9A-Z_a-z]*" => IDENTIFIER,
    r"[0-9]+(?:.[0-9]+)?" => NUMBER,
    "(" => LEFT_PAREN,
    ")" => RIGHT_PAREN,
    "{" => LEFT_BRACE,
    "}" => RIGHT_BRACE,
    ";" => SEMICOLON,
    "," => COMMA,
    "." => DOT,
    "-" => MINUS,
    "+" => PLUS,
    "/" => SLASH,
    "*" => STAR,
    "!=" => BANG_EQUAL,
    "!" => BANG,
    "==" => EQUAL_EQUAL,
    "=" => EQUAL,
    "<=" => LESS_EQUAL,
    "<" => LESS,
    ">=" => GREATER_EQUAL,
    ">" => GREATER,
    r#""[^"]*""# => STRING,
}

extern {
    type Error = crate::error::Error;
}

pub(crate) Program = Declaration*;

Declaration = {
    VAR <name:IDENTIFIER> <init:(EQUAL <Expression>)?> SEMICOLON => Stmt::Var(name.to_owned(), init),
    Statement,
    //TODO others
};

Statement: Stmt = {
    <Expression> SEMICOLON => Stmt::Expr(<>),
    PRINT <Expression> SEMICOLON => Stmt::Print(<>),
    //TODO others
};

Expression: Expr = {
    <lhs:Expression> <op:EqOp> <rhs:Term> => Expr::Binary(Box::new(lhs), op, Box::new(rhs)),
    Term,
};

EqOp: BinaryOp = {
    BANG_EQUAL => BinaryOp::NotEqual,
    EQUAL_EQUAL => BinaryOp::Equal,
};

Term = {
    <lhs:Term> <op:TermOp> <rhs:Factor> => Expr::Binary(Box::new(lhs), op, Box::new(rhs)),
    Factor,
};

TermOp: BinaryOp = {
    MINUS => BinaryOp::Sub,
    PLUS => BinaryOp::Add,
};

Factor = {
    <lhs:Factor> <op:FactorOp> <rhs:Unary> => Expr::Binary(Box::new(lhs), op, Box::new(rhs)),
    Unary,
};

FactorOp: BinaryOp = {
    SLASH => BinaryOp::Div,
    STAR => BinaryOp::Mul,
};

Unary = {
    <op:UnaryOp> <expr:Unary> => Expr::Unary(op, Box::new(expr)),
    TRUE => Expr::True,
    FALSE => Expr::False,
    NIL => Expr::Nil,
    NUMBER =>? f64::from_str(<>).map(Expr::Number).map_err(|e| ParseError::User { error: e.into() }),
    IDENTIFIER => Expr::Variable(<>.to_owned()),
    LEFT_PAREN <Expression> RIGHT_PAREN,
    //TODO others
};

UnaryOp: UnaryOp = {
    BANG => UnaryOp::Not,
    MINUS => UnaryOp::Neg,
};
