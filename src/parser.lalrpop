use {
    std::str::FromStr as _,
    lalrpop_util::ParseError,
    crate::ast::*,
};

grammar;

match {
    r"[\t\n\r ]*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    "and" => AND,
    "class" => CLASS,
    "else" => ELSE,
    "false" => FALSE,
    "for" => FOR,
    "fun" => FUN,
    "if" => IF,
    "nil" => NIL,
    "or" => OR,
    "print" => PRINT,
    "return" => RETURN,
    "super" => SUPER,
    "this" => THIS,
    "true" => TRUE,
    "var" => VAR,
    "while" => WHILE,
    r"[A-Z_a-z][0-9A-Z_a-z]*" => IDENTIFIER,
    r"[0-9]+(?:.[0-9]+)?" => NUMBER,
    "(" => LEFT_PAREN,
    ")" => RIGHT_PAREN,
    "{" => LEFT_BRACE,
    "}" => RIGHT_BRACE,
    ";" => SEMICOLON,
    "," => COMMA,
    "." => DOT,
    "-" => MINUS,
    "+" => PLUS,
    "/" => SLASH,
    "*" => STAR,
    "!=" => BANG_EQUAL,
    "!" => BANG,
    "==" => EQUAL_EQUAL,
    "=" => EQUAL,
    "<=" => LESS_EQUAL,
    "<" => LESS,
    ">=" => GREATER_EQUAL,
    ">" => GREATER,
    r#""[^"]*""# => STRING,
}

extern {
    type Error = crate::error::Error;
}

pub(crate) Program = Declaration*;

Declaration = {
    //TODO classDecl
    //TODO funDecl
    VAR <name:IDENTIFIER> <init:(EQUAL <Expression>)?> SEMICOLON => Stmt::Var(name.to_owned(), init),
    OpenStatement,
    ClosedStatement,
};

Statement = { // to avoid the dangling else problem
    OpenStatement,
    ClosedStatement,
};

OpenStatement: Stmt = {
    //TODO open for
    IF LEFT_PAREN <cond:Expression> RIGHT_PAREN <then:Statement> => Stmt::If(cond, Box::new(then), None),
    IF LEFT_PAREN <cond:Expression> RIGHT_PAREN <then:ClosedStatement> ELSE <else_:OpenStatement> => Stmt::If(cond, Box::new(then), Some(Box::new(else_))),
    //TODO open while
};

ClosedStatement = {
    //TODO closed for
    IF LEFT_PAREN <cond:Expression> RIGHT_PAREN <then:ClosedStatement> ELSE <else_:ClosedStatement> => Stmt::If(cond, Box::new(then), Some(Box::new(else_))),
    //TODO closed while
    SimpleStatement,
};

SimpleStatement: Stmt = {
    <Expression> SEMICOLON => Stmt::Expr(<>),
    PRINT <Expression> SEMICOLON => Stmt::Print(<>),
    //TODO returnStmt
    LEFT_BRACE <Declaration*> RIGHT_BRACE => Stmt::Block(<>),
};

Expression = {
    <name:IDENTIFIER> EQUAL <value:Expression> => Expr::Assign(None, name.to_owned(), Box::new(value)), //TODO field assignment
    LogicOr,
};

LogicOr = { // simple optimization: make `or` right-associative so `true or x or y` only has to jump once
    <lhs:LogicAnd> OR <rhs:LogicOr> => Expr::Binary(Box::new(lhs), BinaryOp::Or, Box::new(rhs)),
    LogicAnd,
};

LogicAnd = { // simple optimization: make `and` right-associative so `false and x and y` only has to jump once
    <lhs:Equality> AND <rhs:LogicAnd> => Expr::Binary(Box::new(lhs), BinaryOp::And, Box::new(rhs)),
    Equality,
};

Equality = {
    <lhs:Equality> <op:EqualityOp> <rhs:Comparison> => Expr::Binary(Box::new(lhs), op, Box::new(rhs)),
    Comparison,
};

EqualityOp: BinaryOp = {
    BANG_EQUAL => BinaryOp::NotEqual,
    EQUAL_EQUAL => BinaryOp::Equal,
};

Comparison = {
    <lhs:Comparison> <op:ComparisonOp> <rhs:Term> => Expr::Binary(Box::new(lhs), op, Box::new(rhs)),
    Term,
};

ComparisonOp: BinaryOp = {
    GREATER => BinaryOp::Greater,
    GREATER_EQUAL => BinaryOp::GreaterEqual,
    LESS => BinaryOp::Less,
    LESS_EQUAL => BinaryOp::LessEqual,
};

Term = {
    <lhs:Term> <op:TermOp> <rhs:Factor> => Expr::Binary(Box::new(lhs), op, Box::new(rhs)),
    Factor,
};

TermOp: BinaryOp = {
    MINUS => BinaryOp::Sub,
    PLUS => BinaryOp::Add,
};

Factor = {
    <lhs:Factor> <op:FactorOp> <rhs:Unary> => Expr::Binary(Box::new(lhs), op, Box::new(rhs)),
    Unary,
};

FactorOp: BinaryOp = {
    SLASH => BinaryOp::Div,
    STAR => BinaryOp::Mul,
};

Unary: Expr = {
    <op:UnaryOp> <expr:Unary> => Expr::Unary(op, Box::new(expr)),
    //TODO call
    TRUE => Expr::True,
    FALSE => Expr::False,
    NIL => Expr::Nil,
    //TODO this
    NUMBER =>? f64::from_str(<>).map(Expr::Number).map_err(|e| ParseError::User { error: e.into() }),
    STRING => {
        let quoted = <>;
        Expr::String(quoted[1..quoted.len() - 1].to_owned())
    },
    IDENTIFIER => Expr::Variable(<>.to_owned()),
    LEFT_PAREN <Expression> RIGHT_PAREN,
    //TODO super
};

UnaryOp: UnaryOp = {
    BANG => UnaryOp::Not,
    MINUS => UnaryOp::Neg,
};
